# 주문 서비스

## Entity
* 각 엔티티의 아이디는 typealias를 가지고 있습니다.

### 1. 주문
* 주문 엔티티의 경우 유저 정보와 상품 정보를 알고 있어야하여 두 엔티티와 연관관계를 가지고 있습니다.
* 주문 상태의 경우 접수(ACCEPTED)와 완료(COMPLETED) 상태를 가지고 있습니다.
* complete함수의 경우 주문 상태를 완료로 바꿔줌과 동시에 마지막 엔티티 변경 시점을 함께 업데이트합니다.

### 2. 유저
* 유저 엔티티의 경우 최소의 데이터만 필요하기 때문에 id, 유저이름 정도만 세팅하였습니다.
* 주문 엔티티는 유저와 연관관계를 맺고 있지만, 현재 시점에서 유저는 주문 엔티티의 정보에 관심이 없기 때문에, 연관관계를 맺고 있지 않습니다.

### 3. 상품
* 상품 엔티티의 경우에도 최소의 데이터만 필요하기 때문에 id, 상품 이름, 가격 정도만 세팅하였습니다.
* 상품 엔티티 또한 현재 시점에 주문 엔티티의 정보에 관심이 없기 때문에, 주문 엔티티와 연관관계를 맺고 있지 않습니다.

## API
* api마다 필요한 id가 다르기 때문에, 헷갈리지 않도록 typealias를 넣어 구분하였습니다.
* userId는 인증이 구현된다면, 따로 request param 또는 path variable로 받지 않고 토큰안에 있는 정보를 가져와 사용하는 것이 좋아보입니다.

### 1. 주문 접수
* 주문 접수 요청은 주문 엔티티가 생성되는 시점입니다.
* 요구사항에서 uri에 {id}값을 UserId로 설정하였습니다.  
* 유저 아이디를 찾지 못할 경우 에러를 발생시킵니다.(테스트 케이스 존재)
* 요청받은 상품 아이디를 찾았을 때 상품 정보가 아예 없다면 에러를 발생시킵니다.(테스트 케이스 존재)
* 현재는 디비에 상품 아이디가 하나라도 존재하면 존재하는 상품에 대해 주문을 만들지만, 요구사항에따라 요청 들어온 상품 아이디 중 하나라도 존재하지 않는다면 주문 접수 자체를 멈추고 에러를 발생시키는 방법도 고려해볼 수 있을 것 같습니다.
* 만들어진 주문 엔티티의 아이디 리스트를 리턴합니다.

### 2. 주문 완료
* 주문 완료 시 주문 엔티티의 주문 상태, 마지막 변경 시점만 변경합니다. 
* 요청온 주문을 조회 할 수 없다면 에러를 발생시킵니다.
* 시나리오에 따라 주문 키를 만들어 주문키로 요청이 들어오면 주문키에 대칭되는 모든 주문을 한번에 완료시키는 시나리오도 고려할 수 있습니다.(현재는 주문키가 없습니다.)
* 주문 키를 고려하지 않은 이유는 요구사항의 api uri에 {id}가 존재하며, 주문키를 id로 만들지 않고 위의 시나리오에는 request param에 주문키만 받으면 되고 그렇다면 uri가 변경되어야하기 때문에 고려하지 않았습니다.
* 주문완료 처리된 주문 엔티티의 아이디를 리턴합니다.

### 3. 주문 단일 조회
* response에는 필요하다고 생각한 정보만 포함하고 있습니다. 
* 주문 아이디가 알맞지 않는다면, 에러를 발생시킵니다.(테스트 케이스 존재)

### 4. 주문 목록 조회
* 유저 엔티티가 존재하는 이유입니다. 
* 유저 아이디로 해당 유저가 가지고 있는 주문 목록을 주문이 만들어진 시점의 시간으로 정렬하여 페이징시킵니다.
* 현재는 프론트 담당자가 없기 때문에, 페이지 객체의 전부를 리턴하고 있지만, 필요 시 페이지 객체의 정보 중 일부만 포함하여 리턴하는 것이 좋아보입니다.

## Controller
* Product, User 컨트롤러는 편의상 포스트맨 호출 시 상품과 유저정보를 세이브하기위해 만들어진 컨트롤러 입니다.

